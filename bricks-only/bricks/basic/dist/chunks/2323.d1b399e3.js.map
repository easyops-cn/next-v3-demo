{"version":3,"file":"chunks/2323.d1b399e3.js","mappings":"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","sources":["webpack:///../../node_modules/@next-core/pipes/dist/esm/index.js","webpack:///../../node_modules/@next-core/inject/dist/esm/interfaces.js","webpack:///../../node_modules/@next-core/inject/dist/esm/lexical.js","webpack:///../../node_modules/@next-core/inject/dist/esm/compile.js","webpack:///../../node_modules/@next-core/inject/dist/esm/syntax.js"],"sourcesContent":["import { pipes } from \"@easyops-cn/brick-next-pipes\";\nexport { pipes, utils } from \"@easyops-cn/brick-next-pipes\";\nvar PipeRegistry = new Map(Array.from(Object.entries(pipes)));\n\n/** For next-core internal usage only. */\nexport function processPipes(value, pipes) {\n  if (pipes.length === 0) {\n    return value;\n  }\n  var result = value;\n  for (var pipe of pipes) {\n    var registeredPipe = PipeRegistry.get(pipe.identifier);\n    if (!registeredPipe) {\n      // eslint-disable-next-line no-console\n      console.warn(\"Unknown pipe: \".concat(pipe.identifier));\n      return;\n    }\n    result = registeredPipe(result, ...pipe.parameters);\n  }\n  return result;\n}\n//# sourceMappingURL=index.js.map","export var LexicalStatus = /*#__PURE__*/function (LexicalStatus) {\n  LexicalStatus[LexicalStatus[\"Initial\"] = 0] = \"Initial\";\n  LexicalStatus[LexicalStatus[\"ExpectField\"] = 1] = \"ExpectField\";\n  LexicalStatus[LexicalStatus[\"ExpectOptionalBeginDefault\"] = 2] = \"ExpectOptionalBeginDefault\";\n  LexicalStatus[LexicalStatus[\"ExpectDefaultValue\"] = 3] = \"ExpectDefaultValue\";\n  LexicalStatus[LexicalStatus[\"ExpectOptionalBeginPipe\"] = 4] = \"ExpectOptionalBeginPipe\";\n  LexicalStatus[LexicalStatus[\"ExpectPipeIdentifier\"] = 5] = \"ExpectPipeIdentifier\";\n  LexicalStatus[LexicalStatus[\"ExpectOptionalBeginPipeParameter\"] = 6] = \"ExpectOptionalBeginPipeParameter\";\n  LexicalStatus[LexicalStatus[\"ExpectPipeParameter\"] = 7] = \"ExpectPipeParameter\";\n  LexicalStatus[LexicalStatus[\"ExpectPlaceholderEnd\"] = 8] = \"ExpectPlaceholderEnd\";\n  return LexicalStatus;\n}({});\nexport var TokenType = /*#__PURE__*/function (TokenType) {\n  TokenType[\"Raw\"] = \"Raw\";\n  TokenType[\"BeginPlaceHolder\"] = \"BeginPlaceHolder\";\n  TokenType[\"Field\"] = \"Field\";\n  TokenType[\"BeginDefault\"] = \"BeginDefault\";\n  TokenType[\"LiteralString\"] = \"LiteralString\";\n  TokenType[\"BeginPipe\"] = \"BeginPipe\";\n  TokenType[\"PipeIdentifier\"] = \"PipeIdentifier\";\n  TokenType[\"BeginPipeParameter\"] = \"BeginPipeParameter\";\n  TokenType[\"EndPlaceHolder\"] = \"EndPlaceHolder\";\n  TokenType[\"JsonValue\"] = \"JsonValue\";\n  return TokenType;\n}({});\nexport var JsonValueType = /*#__PURE__*/function (JsonValueType) {\n  JsonValueType[JsonValueType[\"Array\"] = 0] = \"Array\";\n  JsonValueType[JsonValueType[\"Object\"] = 1] = \"Object\";\n  JsonValueType[JsonValueType[\"String\"] = 2] = \"String\";\n  JsonValueType[JsonValueType[\"Others\"] = 3] = \"Others\";\n  return JsonValueType;\n}({});\n//# sourceMappingURL=interfaces.js.map","import { escapeRegExp } from \"lodash\";\nimport { LexicalStatus, TokenType, JsonValueType } from \"./interfaces.js\";\nexport function getRegExpOfPlaceholder(symbols) {\n  return new RegExp(\"(\".concat([].concat(symbols).map(symbol => escapeRegExp(symbol)).join(\"|\"), \")\\\\{\"));\n}\nexport function tokenize(raw, symbols) {\n  var context = {\n    beginPlaceholder: getRegExpOfPlaceholder(symbols),\n    raw,\n    cursor: 0,\n    status: LexicalStatus.Initial,\n    tokens: []\n  };\n  while (context.cursor < raw.length) {\n    switch (context.status) {\n      case LexicalStatus.Initial:\n        eatOptionalRawAndOptionalPlaceholderBegin(context);\n        break;\n      case LexicalStatus.ExpectField:\n        eatWhitespace(context);\n        eatField(context);\n        break;\n      case LexicalStatus.ExpectOptionalBeginDefault:\n        eatWhitespace(context);\n        eatOptionalDefault(context);\n        break;\n      case LexicalStatus.ExpectDefaultValue:\n        eatWhitespace(context);\n        eatDefaultValue(context);\n        break;\n      case LexicalStatus.ExpectOptionalBeginPipe:\n        eatWhitespace(context);\n        eatOptionalBeginPipe(context);\n        break;\n      case LexicalStatus.ExpectPipeIdentifier:\n        eatWhitespace(context);\n        eatPipeIdentifier(context);\n        break;\n      case LexicalStatus.ExpectOptionalBeginPipeParameter:\n        eatWhitespace(context);\n        eatOptionalBeginPipeParameter(context);\n        break;\n      case LexicalStatus.ExpectPipeParameter:\n        eatWhitespace(context);\n        eatPipeParameter(context);\n        break;\n      case LexicalStatus.ExpectPlaceholderEnd:\n        eatWhitespace(context);\n        eatPlaceholderEnd(context);\n        break;\n    }\n  }\n  if (context.status !== LexicalStatus.Initial) {\n    throw new Error(\"Expected a placeholder end '}' at the end\");\n  }\n  return context.tokens;\n}\nfunction eatOptionalRawAndOptionalPlaceholderBegin(context) {\n  var _subRaw$match;\n  var subRaw = getSubRaw(context);\n  var matchedPlaceholder = (_subRaw$match = subRaw.match(context.beginPlaceholder)) === null || _subRaw$match === void 0 ? void 0 : _subRaw$match[0];\n  var subCursor = matchedPlaceholder ? subRaw.indexOf(matchedPlaceholder) : -1;\n  if (subCursor >= 0 && matchedPlaceholder && subRaw.charAt(subCursor + matchedPlaceholder.length) !== \"{\") {\n    var nextCursor = context.cursor + subCursor;\n    if (subCursor > 0) {\n      context.tokens.push({\n        type: TokenType.Raw,\n        value: subRaw.substring(0, subCursor)\n      });\n    }\n    context.tokens.push({\n      type: TokenType.BeginPlaceHolder,\n      loc: {\n        start: nextCursor,\n        end: nextCursor + matchedPlaceholder.length\n      },\n      value: matchedPlaceholder.substring(0, matchedPlaceholder.length - 1)\n    });\n    context.cursor += subCursor + matchedPlaceholder.length;\n    context.status = LexicalStatus.ExpectField;\n  } else {\n    context.tokens.push({\n      type: TokenType.Raw,\n      value: subRaw\n    });\n    context.cursor = context.raw.length;\n  }\n}\nfunction eatWhitespace(context) {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  context.cursor += getSubRaw(context).match(/^[ \\r\\n\\t]*/)[0].length;\n}\nfunction eatField(context) {\n  // Only allow alphanumeric, `_`, `.`, `*`, `[`, `]`, `-` and other non-ascii.\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  var [value] = getSubRaw(context).match(/^(?:[\\*\\x2D\\.0-9A-\\[\\]_a-z\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*/);\n  context.tokens.push({\n    type: TokenType.Field,\n    value\n  });\n  context.cursor += value.length;\n  context.status = LexicalStatus.ExpectOptionalBeginDefault;\n}\nfunction eatOptionalDefault(context) {\n  if (getSubRaw(context).charAt(0) === \"=\") {\n    context.tokens.push({\n      type: TokenType.BeginDefault\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.ExpectDefaultValue;\n  } else {\n    context.status = LexicalStatus.ExpectOptionalBeginPipe;\n  }\n}\nfunction eatDefaultValue(context) {\n  eatJsonValueOrLiteralString(context, LexicalStatus.ExpectOptionalBeginPipe);\n}\nfunction eatOptionalBeginPipe(context) {\n  if (getSubRaw(context).charAt(0) === \"|\") {\n    context.tokens.push({\n      type: TokenType.BeginPipe\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.ExpectPipeIdentifier;\n  } else {\n    context.status = LexicalStatus.ExpectPlaceholderEnd;\n  }\n}\nfunction eatPipeIdentifier(context) {\n  var matches = getSubRaw(context).match(/^[a-zA-Z]\\w*/);\n  if (!matches) {\n    throw new Error(\"Expected a pipe identifier at index \".concat(context.cursor, \" near: \").concat(JSON.stringify(context.raw.substring(context.cursor))));\n  }\n  var value = matches[0];\n  context.tokens.push({\n    type: TokenType.PipeIdentifier,\n    value\n  });\n  context.cursor += value.length;\n  context.status = LexicalStatus.ExpectOptionalBeginPipeParameter;\n}\nfunction eatOptionalBeginPipeParameter(context) {\n  if (getSubRaw(context).charAt(0) === \":\") {\n    context.tokens.push({\n      type: TokenType.BeginPipeParameter\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.ExpectPipeParameter;\n  } else {\n    context.status = LexicalStatus.ExpectOptionalBeginPipe;\n  }\n}\nfunction eatPipeParameter(context) {\n  eatJsonValueOrLiteralString(context, LexicalStatus.ExpectOptionalBeginPipeParameter);\n}\nfunction eatPlaceholderEnd(context) {\n  if (getSubRaw(context).charAt(0) === \"}\") {\n    context.tokens.push({\n      type: TokenType.EndPlaceHolder,\n      loc: {\n        start: context.cursor,\n        end: context.cursor + 1\n      }\n    });\n    context.cursor += 1;\n    context.status = LexicalStatus.Initial;\n  } else {\n    throw new Error(\"Expected a placeholder end '}' at index \".concat(context.cursor, \" near: \").concat(JSON.stringify(context.raw.substring(context.cursor))));\n  }\n}\nvar jsonLiteralMap = new Map([[\"false\", false], [\"null\", null], [\"true\", true]]);\nfunction eatJsonValueOrLiteralString(context, nextStatus) {\n  var subRaw = getSubRaw(context);\n  if (/[0-9[{\"]/.test(subRaw.charAt(0)) || /-[0-9]/.test(subRaw.substring(0, 2))) {\n    eatJsonValue(context, nextStatus);\n  } else {\n    // Accept any characters except controls and whitespace.\n    // Only allow alphanumeric, `_`, `-` and other non-ascii.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    var [value] = getSubRaw(context).match(/^(?:[\\x2D0-9A-Z_a-z\\x80-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*/);\n    if (jsonLiteralMap.has(value)) {\n      context.tokens.push({\n        type: TokenType.JsonValue,\n        value: jsonLiteralMap.get(value)\n      });\n    } else {\n      context.tokens.push({\n        type: TokenType.LiteralString,\n        value\n      });\n    }\n    context.cursor += value.length;\n    context.status = nextStatus;\n  }\n}\n\n// 我们不需要非常精确地在一段字符串中匹配出一段*完整合法的* JSON value，\n// 而只需要找到一段*可能是完整合法的* JSON value 即可，解析的工作交给 `JSON.parse()`。\n// 由于 JSON 中 object/array/string 的镜像起止符特性，我们尝试去完成这些符号匹配即可。\nfunction eatJsonValue(context, nextStatus) {\n  var subRaw = getSubRaw(context);\n  var firstChar = subRaw.charAt(0);\n  var valueType = firstChar === \"[\" ? JsonValueType.Array : firstChar === \"{\" ? JsonValueType.Object : firstChar === '\"' ? JsonValueType.String : JsonValueType.Others;\n  var subCursor = 0;\n  var objectBracesToMatch = 0;\n  var arrayBracketsToMatch = 0;\n  var stringQuotesToClose = false;\n  var stringBackslashToEscape = false;\n  var matched = false;\n  while (subCursor < subRaw.length) {\n    var char = subRaw.charAt(subCursor);\n    if (stringBackslashToEscape) {\n      stringBackslashToEscape = false;\n    } else if (stringQuotesToClose) {\n      if (char === '\"') {\n        stringQuotesToClose = false;\n      } else if (char === \"\\\\\") {\n        stringBackslashToEscape = true;\n      }\n    } else {\n      switch (char) {\n        case \"[\":\n          arrayBracketsToMatch += 1;\n          break;\n        case \"{\":\n          objectBracesToMatch += 1;\n          break;\n        case \"]\":\n          arrayBracketsToMatch -= 1;\n          break;\n        case \"}\":\n          objectBracesToMatch -= 1;\n          break;\n        case '\"':\n          stringQuotesToClose = true;\n          break;\n      }\n    }\n    subCursor += 1;\n    switch (valueType) {\n      case JsonValueType.Array:\n        matched = !arrayBracketsToMatch;\n        break;\n      case JsonValueType.Object:\n        matched = !objectBracesToMatch;\n        break;\n      case JsonValueType.String:\n        matched = !stringQuotesToClose;\n        break;\n      default:\n        // 对于其它类型，如果下一个字符不再是这些值类型可能的字符时，我们认为 JSON value 完成匹配。\n        // 其它可能的值类型：number/boolean/null/undefined。\n        matched = subCursor < subRaw.length && /[^a-z0-9E.+-]/.test(subRaw.charAt(subCursor));\n    }\n    if (matched) {\n      break;\n    }\n  }\n  if (!matched) {\n    throw new Error(\"Failed to match a JSON value at index \".concat(context.cursor, \" near: \").concat(JSON.stringify(context.raw.substring(context.cursor))));\n  }\n  context.tokens.push({\n    type: TokenType.JsonValue,\n    value: JSON.parse(subRaw.substring(0, subCursor))\n  });\n  context.cursor += subCursor;\n  context.status = nextStatus;\n}\nfunction getSubRaw(context) {\n  return context.raw.substring(context.cursor);\n}\n//# sourceMappingURL=lexical.js.map","import { get } from \"lodash\";\nimport { processPipes } from \"@next-core/pipes\";\nimport { parseInjectableString } from \"./syntax.js\";\nimport { getRegExpOfPlaceholder } from \"./lexical.js\";\nexport function transform(raw, context) {\n  return compile(raw, \"@\", context);\n}\nexport function inject(raw, context) {\n  return compile(raw, \"$\", context);\n}\nexport function transformAndInject(raw, context) {\n  return compile(raw, [\"@\", \"$\"], context);\n}\nfunction compile(raw, symbols, context) {\n  // const symbols = [\"@\", \"$\"];\n  if (!isInjectable(raw, symbols)) {\n    return raw;\n  }\n  var transformNode = transformNodeFactory(context.data);\n  var injectNode = injectNodeFactory(context, raw);\n  var tree = parseInjectableString(raw, symbols);\n  var values = tree.elements.map(node => node.type === \"RawString\" ? node.value : node.symbol === \"$\" ? injectNode(node) : transformNode(node));\n  return reduceCompiledValues(values);\n}\nfunction reduceCompiledValues(values) {\n  // If the whole string is a placeholder, we should keep the original value.\n  if (values.length === 1) {\n    return values[0];\n  }\n\n  // If an element is `undefined`, `null` or an empty array `[]`, it is converted to an empty string.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join#Description\n  return values.join(\"\");\n}\nfunction isInjectable(raw, symbols) {\n  return getRegExpOfPlaceholder(symbols).test(raw);\n}\nfunction transformNodeFactory(data) {\n  return function transformNode(node) {\n    // If meet `@{}`, return `data`.\n    var result = node.field ? get(data, node.field) : data;\n    if (result === undefined) {\n      result = node.defaultValue;\n    }\n    return processPipes(result, node.pipes);\n  };\n}\nfunction injectNodeFactory(context, raw) {\n  return function injectNode(node) {\n    var _context$overrideApp, _context$overrideApp2;\n    var matches = node.field.match(/^(?:(QUERY(?:_ARRAY)?|EVENT|query|event|APP|HASH|ANCHOR|SYS|FLAGS|CTX)\\.)?(.+)$/);\n    if (!matches) {\n      // Keep the original raw partial when meet a unknown namespace.\n      return raw.substring(node.loc.start, node.loc.end);\n    }\n    var [, namespace, subField] = matches;\n\n    // Support namespace with no subfield such as `${ANCHOR}`.\n    // But distinguish with match params. E.g. `${query}` is a match param.\n    if (!namespace && /^[A-Z_]+$/.test(subField)) {\n      namespace = subField;\n      subField = \"*\";\n    }\n    var result;\n    var SimpleContextMap = {\n      SYS: \"sys\",\n      FLAGS: \"flags\"\n    };\n    switch (namespace) {\n      case \"QUERY\":\n      case \"query\":\n        if (subField === \"*\") {\n          result = context.query;\n        } else {\n          result = context.query.has(subField) ? context.query.get(subField) : undefined;\n        }\n        break;\n      case \"QUERY_ARRAY\":\n        result = context.query.has(subField) ? context.query.getAll(subField) : undefined;\n        break;\n      case \"EVENT\":\n      case \"event\":\n        if (context.event === undefined) {\n          // Keep the original raw partial when meet a `${EVENT}` in non-event context.\n          return raw.substring(node.loc.start, node.loc.end);\n        }\n        result = subField === \"*\" ? context.event : get(context.event, subField);\n        break;\n      case \"APP\":\n        result = subField === \"*\" ? (_context$overrideApp = context.overrideApp) !== null && _context$overrideApp !== void 0 ? _context$overrideApp : context.app : get((_context$overrideApp2 = context.overrideApp) !== null && _context$overrideApp2 !== void 0 ? _context$overrideApp2 : context.app, subField);\n        break;\n      case \"HASH\":\n        result = context.location.hash;\n        break;\n      case \"SYS\":\n      case \"FLAGS\":\n        result = subField === \"*\" ? context[SimpleContextMap[namespace]] : get(context[SimpleContextMap[namespace]], subField);\n        break;\n      case \"ANCHOR\":\n        {\n          var anchor = context.location.hash ? context.location.hash.substr(1) : null;\n          result = subField === \"*\" ? anchor : get(anchor, subField);\n          break;\n        }\n      case \"CTX\":\n        {\n          var original = raw.substring(node.loc.start, node.loc.end);\n          // eslint-disable-next-line no-console\n          console.error(\"CTX is not supported in placeholder any more: \\\"\".concat(original, \"\\\"\"));\n          return original;\n        }\n      default:\n        if (context.match) {\n          result = context.match.params[subField];\n        } else {\n          // If the context is empty, return the original raw partial.\n          return raw.substring(node.loc.start, node.loc.end);\n        }\n    }\n    if (result === undefined) {\n      result = node.defaultValue;\n    }\n    return processPipes(result, node.pipes);\n  };\n}\n//# sourceMappingURL=compile.js.map","import { tokenize } from \"./lexical.js\";\nimport { TokenType } from \"./interfaces.js\";\nexport function parseInjectableString(raw, symbols) {\n  return parseTokens(tokenize(raw, symbols));\n}\nfunction parseTokens(tokens) {\n  var tree = {\n    type: \"InjectableString\",\n    elements: []\n  };\n  var token;\n  function optionalToken(type) {\n    if (type === tokens[0].type) {\n      token = tokens.shift();\n      return true;\n    }\n    return false;\n  }\n  function acceptToken(type) {\n    token = tokens.shift();\n    if (Array.isArray(type) ? !type.includes(token.type) : type !== token.type) {\n      throw new Error(\"Expected token: \".concat(type, \", received token: \").concat(token.type));\n    }\n  }\n  while (tokens.length > 0) {\n    if (optionalToken(TokenType.Raw)) {\n      tree.elements.push({\n        type: \"RawString\",\n        value: token.value\n      });\n    } else {\n      acceptToken(TokenType.BeginPlaceHolder);\n      var start = token.loc.start;\n      var symbol = token.value;\n      acceptToken(TokenType.Field);\n      var placeholder = {\n        type: \"Placeholder\",\n        symbol,\n        field: token.value,\n        defaultValue: undefined,\n        pipes: [],\n        loc: {\n          start,\n          end: start\n        }\n      };\n      tree.elements.push(placeholder);\n      if (optionalToken(TokenType.BeginDefault)) {\n        acceptToken([TokenType.JsonValue, TokenType.LiteralString]);\n        placeholder.defaultValue = token.value;\n      }\n      while (optionalToken(TokenType.BeginPipe)) {\n        acceptToken(TokenType.PipeIdentifier);\n        var pipe = {\n          type: \"PipeCall\",\n          identifier: token.value,\n          parameters: []\n        };\n        placeholder.pipes.push(pipe);\n        while (optionalToken(TokenType.BeginPipeParameter)) {\n          acceptToken([TokenType.JsonValue, TokenType.LiteralString]);\n          pipe.parameters.push(token.value);\n        }\n      }\n      acceptToken(TokenType.EndPlaceHolder);\n      placeholder.loc.end = token.loc.end;\n    }\n  }\n  return tree;\n}\n//# sourceMappingURL=syntax.js.map"],"names":["PipeRegistry","Map","Array","from","Object","entries","processPipes","value","pipes","length","result","pipe","registeredPipe","get","identifier","console","warn","concat","parameters","LexicalStatus","TokenType","JsonValueType","getRegExpOfPlaceholder","symbols","RegExp","map","symbol","escapeRegExp","join","eatOptionalRawAndOptionalPlaceholderBegin","context","_subRaw$match","subRaw","getSubRaw","matchedPlaceholder","match","beginPlaceholder","subCursor","indexOf","charAt","nextCursor","cursor","tokens","push","type","Raw","substring","BeginPlaceHolder","loc","start","end","status","ExpectField","raw","eatWhitespace","eatField","Field","ExpectOptionalBeginDefault","eatOptionalDefault","BeginDefault","ExpectDefaultValue","ExpectOptionalBeginPipe","eatDefaultValue","eatJsonValueOrLiteralString","eatOptionalBeginPipe","BeginPipe","ExpectPipeIdentifier","ExpectPlaceholderEnd","eatPipeIdentifier","matches","Error","JSON","stringify","PipeIdentifier","ExpectOptionalBeginPipeParameter","eatOptionalBeginPipeParameter","BeginPipeParameter","ExpectPipeParameter","eatPipeParameter","eatPlaceholderEnd","EndPlaceHolder","Initial","jsonLiteralMap","nextStatus","test","firstChar","valueType","String","Others","objectBracesToMatch","arrayBracketsToMatch","stringQuotesToClose","stringBackslashToEscape","matched","char","JsonValue","parse","eatJsonValue","has","LiteralString","transform","compile","inject","transformAndInject","isInjectable","data","values","transformNode","node","field","undefined","defaultValue","injectNode","_context$overrideApp","_context$overrideApp2","namespace","subField","SimpleContextMap","SYS","FLAGS","query","getAll","event","overrideApp","app","location","hash","anchor","substr","original","error","params","injectNodeFactory","token","tree","elements","optionalToken","shift","acceptToken","isArray","includes","placeholder","parseTokens","tokenize","parseInjectableString"],"sourceRoot":""}